<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CS61Bnote | LST's blog</title><meta name="author" content="LST"><meta name="copyright" content="LST"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CS61B NOTE2.Lists2.1引入1234567b的变化会影响a吗？ Walrus a &#x3D; new Walrus(1000, 8.3);Walrus b;b &#x3D; a;b.weight &#x3D; 5;System.out.println(a);System.out.println(b);      会。它是一个指向  引用类型123456789public static class Walrus">
<meta property="og:type" content="article">
<meta property="og:title" content="CS61Bnote">
<meta property="og:url" content="https://cuso41108.github.io/2025/03/09/CS61Bnote/index.html">
<meta property="og:site_name" content="LST&#39;s blog">
<meta property="og:description" content="CS61B NOTE2.Lists2.1引入1234567b的变化会影响a吗？ Walrus a &#x3D; new Walrus(1000, 8.3);Walrus b;b &#x3D; a;b.weight &#x3D; 5;System.out.println(a);System.out.println(b);      会。它是一个指向  引用类型123456789public static class Walrus">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cuso41108.github.io/img/luffy.png">
<meta property="article:published_time" content="2025-03-08T16:00:00.000Z">
<meta property="article:modified_time" content="2025-03-13T12:58:50.395Z">
<meta property="article:author" content="LST">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cuso41108.github.io/img/luffy.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CS61Bnote",
  "url": "https://cuso41108.github.io/2025/03/09/CS61Bnote/",
  "image": "https://cuso41108.github.io/img/luffy.png",
  "datePublished": "2025-03-08T16:00:00.000Z",
  "dateModified": "2025-03-13T12:58:50.395Z",
  "author": [
    {
      "@type": "Person",
      "name": "LST",
      "url": "https://cuso41108.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cuso41108.github.io/2025/03/09/CS61Bnote/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CS61Bnote',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/luffy.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/%E7%94%B5%E5%BD%B1/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/space.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/luffy.png" alt="Logo"><span class="site-name">LST's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">CS61Bnote</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/%E9%9F%B3%E4%B9%90/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/%E7%94%B5%E5%BD%B1/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CS61Bnote</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-08T16:00:00.000Z" title="Created 2025-03-09 00:00:00">2025-03-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-03-13T12:58:50.395Z" title="Updated 2025-03-13 20:58:50">2025-03-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="CS61B-NOTE"><a href="#CS61B-NOTE" class="headerlink" title="CS61B NOTE"></a>CS61B NOTE</h2><h3 id="2-Lists"><a href="#2-Lists" class="headerlink" title="2.Lists"></a>2.Lists</h3><h5 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h5><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b的变化会影响a吗？ </span><br><span class="line"><span class="type">Walrus</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Walrus</span>(<span class="number">1000</span>, <span class="number">8.3</span>);</span><br><span class="line">Walrus b;</span><br><span class="line">b = a;</span><br><span class="line">b.weight = <span class="number">5</span>;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);    </span><br></pre></td></tr></table></figure>

<p>会。它是一个指向 </p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Walrus</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> tuskSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Walrus</span><span class="params">(<span class="type">int</span> w, <span class="type">double</span> ts)</span> &#123;</span><br><span class="line">          weight = w;</span><br><span class="line">          tuskSize = ts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>函数传递参数时，实际上只是在复制位。</p>
<h4 id="数组实例化"><a href="#数组实例化" class="headerlink" title="数组实例化"></a>数组实例化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">95</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="2-2-SLList"><a href="#2-2-SLList" class="headerlink" title="2.2 SLList"></a>2.2 SLList</h5><p>对比IntList，更像是作为一个中介<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig22/IntList_vs_SLList.png" alt="IntList_vs_SLList.png" style="zoom: 33%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">public</span> IntNode next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i,IntNode n)</span>&#123;</span><br><span class="line">        item = i;</span><br><span class="line">        next=n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> IntNode first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SLList L= <span class="keyword">new</span> <span class="title class_">SLList</span>(<span class="number">10</span>); <span class="comment">//这样就不必用空值了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h4><p>如果你没有使用外部类的任何实例成员，则将嵌套类设为静态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntNode</span> &#123;</span><br><span class="line">		如果嵌套类不需要使用 SLList 的任何实例方法或变量，则可以声明嵌套类 <span class="keyword">static</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> item;</span><br><span class="line">            <span class="keyword">public</span> IntNode next;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">IntNode</span><span class="params">(<span class="type">int</span> i, IntNode n)</span> &#123;</span><br><span class="line">                item = i;</span><br><span class="line">                next = n;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> IntNode first;</span><br></pre></td></tr></table></figure>

<p>递归调用 <code>size</code> 在 <code>IntList</code> 中很简单： <code>return 1 + this.rest.size()</code> 。但对于 <code>SLList</code> ，这种方法没有意义， <code>SLList</code> 没有 <code>rest</code> 变量。所以要used with middleman classes</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(IntNode p)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.next==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+size(p.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size(first);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方法1.都命名为 <code>size</code> ，在 Java 中这是允许的，因为它们的参数不同。我们说具有相同名称但不同签名的两个方法是<strong>重载</strong>的。</p>
<p>方法2：在 <code>IntNode</code> 类本身创建一个非静态辅助方法。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>增加一个size变量，这样检索更快</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SLList</span> &#123;</span><br><span class="line">    ... <span class="comment">/* IntNode declaration omitted. */</span></span><br><span class="line">    <span class="keyword">private</span> IntNode first;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, <span class="literal">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, first);</span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哨兵节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IntNode sentinel;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">()</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">IntNode</span>(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SLList</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">IntNode</span>(-<span class="number">1</span>, <span class="literal">null</span>);</span><br><span class="line">        sentinel.next= <span class="keyword">new</span> <span class="title class_">IntNode</span>(x,<span class="literal">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        sentinel.next = <span class="keyword">new</span> <span class="title class_">IntNode</span>(x, sentinel.next);<span class="comment">//sentinel永远指向同一个</span></span><br><span class="line">        size += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next.item;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        size = size+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        IntNode p=sentinel;</span><br><span class="line">        <span class="keyword">while</span>(p.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next=<span class="keyword">new</span> <span class="title class_">IntNode</span>(x,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3双向链表"><a href="#2-3双向链表" class="headerlink" title="2.3双向链表"></a>2.3双向链表</h4><img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_basic_size_0.png" alt="dllist_basic_size_0.png" style="zoom: 50%;" />

<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_basic_size_2.png" alt="dllist_basic_size_2.png" style="zoom:50%;" />

<p> 问题：<code>last</code> 指针有时指向哨兵节点，有时指向实际节点。</p>
<p>一种解决方案是在链表末尾添加第二个哨兵节点。<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_double_sentinel_size_2.png" alt="dllist_double_sentinel_size_2.png" style="zoom:50%;" /></p>
<p>另一种方法是实现一个循环列表，其中前后指针共享同一个哨兵节点。</p>
<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_0.png" alt="dllist_circular_sentinel_size_0.png" style="zoom:50%;" />

<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig23/dllist_circular_sentinel_size_2.png" alt="dllist_circular_sentinel_size_2.png" style="zoom: 50%;" />

<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printer</span> &lt;&gt;&#123;</span><br><span class="line">    T thingToPrint;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Printer</span><span class="params">(T thingToPrint)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.thingToPrint = thingToPrint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(thingToPrint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsExample</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		Printer&lt;Integer&gt;printer = <span class="keyword">new</span> <span class="title class_">Printer</span>&lt;&gt;(<span class="number">23</span>);</span><br><span class="line">		printer.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例化:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DLList&lt;String&gt; d2 = <span class="keyword">new</span> <span class="title class_">DLList</span>&lt;&gt;(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">d2.addLast(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>int:Integer    double:Double   char:Character   boolean:Boolean   long:Long</p>
<h5 id="2-4数组"><a href="#2-4数组" class="headerlink" title="2.4数组"></a>2.4数组</h5><ul>
<li><code>x = new int[3];</code></li>
<li><code>y = new int[]&#123;1, 2, 3, 4, 5&#125;;</code></li>
<li>int[] z &#x3D; {9, 10, 11, 12, 13};&#96;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(b, <span class="number">0</span>, x, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">原数组b，原数组从<span class="number">0</span>开始，目标数组x，目标数组从第<span class="number">3</span>项开始，<span class="number">2</span>项要复制</span><br><span class="line">等同于 Python 中的 x[<span class="number">3</span>:<span class="number">5</span>] = b[<span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>



<h4 id="Resizing-Arrays调整数组大小"><a href="#Resizing-Arrays调整数组大小" class="headerlink" title="Resizing Arrays调整数组大小"></a>Resizing Arrays调整数组大小</h4><p>仅仅是加了项，创建副本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[size + <span class="number">1</span>];</span><br><span class="line">System.arraycopy(items, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">a[size] = <span class="number">11</span>;</span><br><span class="line">items = a;</span><br><span class="line">size = size + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这样用＋太慢，而且当RFACTOR太大又占用空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertBack</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == items.length) &#123;</span><br><span class="line">           resize(size + RFACTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    items[size] = x;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以这样调整大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertBack</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == items.length) &#123;</span><br><span class="line">           resize(size * RFACTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    items[size] = x;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义一个<strong>“使用率”R</strong>，它等于列表的大小除以 <code>items</code> 数组长度。比如下图：使用率为0.04</p>
<img src="https://joshhug.gitbooks.io/hug61b/content/chap2/fig25/usage_ratio.png" alt="fig25/usage_ratio.png" style="zoom:25%;" />

<p>在一个典型实现中，当 R 降至 0.25 以下时，我们将数组大小减半。</p>
<h4 id="3-1JUnit-测试"><a href="#3-1JUnit-测试" class="headerlink" title="3.1JUnit 测试"></a>3.1JUnit 测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSort</span> &#123;</span><br><span class="line">    <span class="comment">/** Tests the sort method of the Sort class. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testSort</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] input = &#123;<span class="string">&quot;i&quot;</span>, <span class="string">&quot;have&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;egg&quot;</span>&#125;;</span><br><span class="line">        String[] expected = &#123;<span class="string">&quot;an&quot;</span>, <span class="string">&quot;egg&quot;</span>, <span class="string">&quot;have&quot;</span>, <span class="string">&quot;i&quot;</span>&#125;;</span><br><span class="line">        Sort.sort(input);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; input.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!input[i].equals(expected[i])) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Mismatch in position &quot;</span> + i + <span class="string">&quot;, expected: &quot;</span> + expected + <span class="string">&quot;, but got: &quot;</span> + input[i] + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//这样输出过于繁琐</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        testSort();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>org.junit</code> 库提供了一些有助于简化测试编写的实用方法和功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testSort</span><span class="params">()</span> &#123;</span><br><span class="line">    String[] input = &#123;<span class="string">&quot;i&quot;</span>, <span class="string">&quot;have&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;egg&quot;</span>&#125;;</span><br><span class="line">    String[] expected = &#123;<span class="string">&quot;an&quot;</span>, <span class="string">&quot;egg&quot;</span>, <span class="string">&quot;have&quot;</span>, <span class="string">&quot;i&quot;</span>&#125;;</span><br><span class="line">    Sort.sort(input);</span><br><span class="line">    org.junit.Assert.assertArrayEquals(expected, input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="怎么比较字符串："><a href="#怎么比较字符串：" class="headerlink" title="怎么比较字符串："></a>怎么比较字符串：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1.compareTo(str2) method will <span class="keyword">return</span> a negative number <span class="keyword">if</span> str1 &lt; str2, <span class="number">0</span> <span class="keyword">if</span> they are equal, and a positive number <span class="keyword">if</span> str1 &gt; str2</span><br></pre></td></tr></table></figure>



<h4 id="递归时用私有辅助方法"><a href="#递归时用私有辅助方法" class="headerlink" title="递归时用私有辅助方法"></a>递归时用私有辅助方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Sorts strings destructively. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(String[] x)</span> &#123; </span><br><span class="line">   <span class="type">int</span> <span class="variable">smallestIndex</span> <span class="operator">=</span> findSmallest(x);</span><br><span class="line">   swap(x, <span class="number">0</span>, smallestIndex);</span><br><span class="line">   sort(x[<span class="number">1</span>:])<span class="comment">//但是java并没有切片功能，×</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(String[] x, <span class="type">int</span> start)</span> &#123; <span class="comment">//有了额外的参数 start</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">smallestIndex</span> <span class="operator">=</span> findSmallest(x);</span><br><span class="line">   swap(x, start, smallestIndex);</span><br><span class="line">   sort(x, start + <span class="number">1</span>);</span><br><span class="line">&#125;<span class="comment">//现在我们设置正确的原始调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(String[] x)</span> &#123; </span><br><span class="line">   sort(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-1继承，实现"><a href="#4-1继承，实现" class="headerlink" title="4.1继承，实现"></a>4.1继承，实现</h5><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>让某方法也适用于 AList </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">把<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longest</span><span class="params">(SLList&lt;String&gt; list)</span>改成</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longest</span><span class="params">(AList&lt;String&gt; list)</span></span><br></pre></td></tr></table></figure>

<p>Java 会根据你提供的参数类型来知道运行哪个。如果你提供 AList，它将调用 AList 方法。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>首先如果 SLList 是 List61B 的下义词，则 SLList 类是 List61B 类的<strong>子类</strong>，而 List61B 类是 SLList 类的<strong>超类</strong>。<img src="https://joshhug.gitbooks.io/hug61b/content/assets/subclass.png" alt="subclass" style="zoom: 50%;" /></p>
<p>表达这个层次结构的步骤：</p>
<ul>
<li>第一步：定义一个用于通用列表超类型的类型 – 我们将选择名称 List61B。</li>
<li>第二步：指定 SLList 和 AList 是该类型的下位词。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List61B</span>&lt;Item&gt; &#123;<span class="comment">//这是List61B接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(Item x)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> add <span class="title function_">Last</span><span class="params">(Item y)</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">getLast</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">removeLast</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item x, <span class="type">int</span> position)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//现在指定 AList 和 SLList 是 List61B 类的下位词</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AList</span>&lt;Item&gt; <span class="keyword">implements</span> <span class="title class_">List61B</span>&lt;Item&gt;&#123;...&#125;</span><br></pre></td></tr></table></figure>



<h4 id="覆盖Override"><a href="#覆盖Override" class="headerlink" title="覆盖Override"></a>覆盖Override</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">方便编译，检查拼写错误</span><br></pre></td></tr></table></figure>

<h4 id="Interface-Inheritance-接口继承"><a href="#Interface-Inheritance-接口继承" class="headerlink" title="Interface Inheritance 接口继承"></a>Interface Inheritance 接口继承</h4><img src="https://joshhug.gitbooks.io/hug61b/content/assets/subclass.png" alt="subclass" style="zoom: 50%;" />

<p>接口继承指的是子类继承父类所有方法&#x2F;行为的关系。例如，在“同义词和上位词”部分中我们定义的 List61B 类，接口包括所有方法签名，但不包括实现。具体实现由子类提供。</p>
<p>这种继承是多代的。这意味着如果我们有一个像图 4.1.1 中那样的长序列的超类&#x2F;子类关系，AList 不仅继承自 List61B 的方法，还继承自它上面的所有其他类，一直到最高超类，即 AList 继承自 Collection。</p>
<h4 id="Implementation-Inheritance-实现继承"><a href="#Implementation-Inheritance-实现继承" class="headerlink" title="Implementation Inheritance 实现继承"></a>Implementation Inheritance 实现继承</h4><p>关键字<strong>default</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果我们在 List61B定义这个方法</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size(); i += <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.print(get(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">然后，所有实现 List61B 类的都可以使用该方法！</span><br></pre></td></tr></table></figure>

<p>接口继承（是什么）：简单地说明子类应该能够做什么。</p>
<ul>
<li>所有列表都应该能够打印自身，它们如何做到这一点由它们自己决定。</li>
</ul>
<p>实现继承（如何）：告诉子类它们应该如何表现。</p>
<ul>
<li>列表应该以这种方式打印出来：先按顺序获取每个元素，然后打印它们。</li>
</ul>
<h5 id="4-2Extend"><a href="#4-2Extend" class="headerlink" title="4.2Extend"></a>4.2Extend</h5><p>继承允许子类重用已定义类中的代码。现在我们定义 RotatingSLList 类，使其继承自 SLList。</p>
<p>我们可以使用 <code>extends</code> 关键字在类头中设置这种继承关系，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RotatingSLList</span>&lt;Item&gt; <span class="keyword">extends</span> <span class="title class_">SLList</span>&lt;Item&gt;</span><br></pre></td></tr></table></figure>

<p><strong>构造函数不会被继承</strong>，私有成员不能被子类直接访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VengefulSLList</span>&lt;Item&gt; <span class="keyword">extends</span> <span class="title class_">SLList</span>&lt;Item&gt; &#123;</span><br><span class="line">    SLList&lt;Item&gt; deletedItems;<span class="comment">/* =new SLList&lt;Item&gt;();效果与下面相同*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">()</span> &#123;</span><br><span class="line">        deletedItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Item&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Item <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Item</span> <span class="variable">x</span> <span class="operator">=</span> <span class="built_in">super</span>.removeLast();<span class="comment">/***调用父类的方法*/</span></span><br><span class="line">        deletedItems.addLast(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Prints deleted items. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLostItems</span><span class="params">()</span> &#123;</span><br><span class="line">        deletedItems.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造函数不可继承"><a href="#构造函数不可继承" class="headerlink" title="构造函数不可继承:"></a>构造函数不可继承:</h5><p>比如有两个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Human</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TA</span> <span class="keyword">extends</span> <span class="title class_">Human</span> &#123;...&#125;</span><br><span class="line">如果运行 <span class="type">TA</span> <span class="variable">Christine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TA</span>();</span><br><span class="line">首先，必须创建一个人类。然后，那个人类可以被赋予助教的品质。在没有首先创建人类的情况下构建助教是没有意义的。</span><br><span class="line"></span><br><span class="line">因此，我们可以显式地调用超类的构造函数，使用 <span class="built_in">super</span> 关键字：</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    deletedItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Item&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">VengefulSLList</span><span class="params">(Item x)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(x);</span><br><span class="line">    deletedItems = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Item&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="The-Object-Class"><a href="#The-Object-Class" class="headerlink" title="The Object Class"></a>The Object Class</h4><p>Interface don’t extend Object.</p>
<p>Object 类提供了很多基本的方法，例如<code>toString()</code> ， <code>equals()</code> 等</p>
<h4 id="抽象屏障"><a href="#抽象屏障" class="headerlink" title="抽象屏障"></a>抽象屏障</h4><p>隐藏用户不需要知道的东西</p>
<h4 id="Type-Checking-and-Casting"><a href="#Type-Checking-and-Casting" class="headerlink" title="Type Checking and Casting"></a>Type Checking and Casting</h4><p>静态类型，动态类型</p>
<p>记住，编译器根据对象的静态类型确定某事物是否有效<img src="https://joshhug.gitbooks.io/hug61b/content/assets/dynamic_selection.png" alt="img" style="zoom:33%;" />倒数第二行：由于 <code>sl</code> 的静态类型为 SLList，而 <code>printLostItems</code> 未在 SLList 类中定义，即使 <code>sl</code> 的运行时类型为 VengefulSLList，代码也不允许运行。</p>
<p>倒数第一行：一般来说，编译器只允许基于编译时类型的调用和赋值。由于编译器只看到 <code>sl</code> 的静态类型是 SLList，它不会允许一个 VengefulSLList “容器”来持有它。</p>
<h4 id="Expressions"><a href="#Expressions" class="headerlink" title="Expressions"></a>Expressions</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SLList&lt;Integer&gt; sl = <span class="keyword">new</span> <span class="title class_">VengefulSLList</span>&lt;Integer&gt;();<span class="comment">//正确</span></span><br><span class="line">上述表达式的右侧编译时类型为 VengefulSLList。编译器检查以确保 VengefulSLList“是”SLList 的子类，并允许这种赋值</span><br><span class="line"></span><br><span class="line">VengefulSLList&lt;Integer&gt; vsl = <span class="keyword">new</span> <span class="title class_">SLList</span>&lt;Integer&gt;();<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>



<h4 id="Casting"><a href="#Casting" class="headerlink" title="Casting"></a>Casting</h4><p>类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poodle</span> <span class="variable">largerPoodle</span> <span class="operator">=</span> (Poodle) maxDog(frank, frankJr); <span class="comment">// compiles! Right hand side has compile-time type Poodle after casting</span></span><br></pre></td></tr></table></figure>

<p>类型转换的风险</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Poodle</span> <span class="variable">frank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Poodle</span>(<span class="string">&quot;Frank&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">Malamute</span> <span class="variable">frankSr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Malamute</span>(<span class="string">&quot;Frank Sr.&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Poodle</span> <span class="variable">largerPoodle</span> <span class="operator">=</span> (Poodle) maxDog(frank, frankSr); <span class="comment">// runtime exception!</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，我们比较了一只贵宾犬和一只马尔穆特犬。没有类型转换，编译器通常不会允许调用 <code>maxDog</code> 进行编译，因为右侧的编译时类型将是 Dog，而不是 Poodle。然而，类型转换允许这段代码通过，当 <code>maxDog</code> 在运行时返回马尔穆特犬，并且我们尝试将马尔穆特犬转换为贵宾犬时，我们会遇到运行时异常 - 一个 <code>ClassCastException</code> </p>
<h4 id="Inheritance-Cheatsheet"><a href="#Inheritance-Cheatsheet" class="headerlink" title="Inheritance Cheatsheet"></a>Inheritance Cheatsheet</h4><p><code>VengefulSLList extends SLList</code> 表示 VengefulSLList 是 SLList ，并继承所有 SLList 的成员：</p>
<h4 id="Higher-Order-Functions"><a href="#Higher-Order-Functions" class="headerlink" title="Higher Order Functions"></a>Higher Order Functions</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个接口，定义任何接受整数并返回整数的函数 - 一个 IntUnaryFunction 。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IntUnaryFunction</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在我们可以编写一个类来表示一个具体函数。让我们编写一个函数，它接受一个整数并返回该整数的 10 倍。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TenX</span> <span class="keyword">implements</span> <span class="title class_">IntUnaryFunction</span> &#123;</span><br><span class="line">    <span class="comment">/* Returns ten times the argument. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">apply</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span> * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这个阶段，我们已经用 Java 实现了 Python 中的 tenX 函数的等价功能。现在我们来写 do_twice 。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">do_twice</span><span class="params">(IntUnaryFunction f, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f.apply(f.apply(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java 中调用 print(do_twice(tenX, 2)) 的代码如下：</span></span><br><span class="line">System.out.println(do_twice(<span class="keyword">new</span> <span class="title class_">TenX</span>(), <span class="number">2</span>));</span><br></pre></td></tr></table></figure>



<h5 id="4-3Subtype-Polymorphism"><a href="#4-3Subtype-Polymorphism" class="headerlink" title="4.3Subtype Polymorphism"></a>4.3Subtype Polymorphism</h5><p>子类型多态。为不同类型的实体提供单一接口</p>
<ol>
<li>Explicit HoF Approach 显式 HoF 方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_larger</span>(<span class="params">x, y, compare, stringify</span>):</span><br><span class="line">    <span class="keyword">if</span> compare(x, y):</span><br><span class="line">        <span class="keyword">return</span> stringify(x)</span><br><span class="line">    <span class="keyword">return</span> stringify(y)</span><br></pre></td></tr></table></figure>

<ol>
<li>Subtype Polymorphism Approach<br>子类型多态方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_larger</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">if</span> x.largerThan(y):</span><br><span class="line">        <span class="keyword">return</span> x.<span class="built_in">str</span>()</span><br><span class="line">    <span class="keyword">return</span> y.<span class="built_in">str</span>()</span><br></pre></td></tr></table></figure>

<p>问题背景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">max</span><span class="params">(Object[] items)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; items.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (items[i] &gt; items[maxDex]) &#123;<span class="comment">//  Complilation Error</span></span><br><span class="line">            maxDex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> items[maxDex];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Dog[] dogs = &#123;<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Elyse&quot;</span>, <span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Sture&quot;</span>, <span class="number">9</span>), <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Benjamin&quot;</span>, <span class="number">15</span>)&#125;;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">maxDog</span> <span class="operator">=</span> (Dog) max(dogs);</span><br><span class="line">    maxDog.bark();</span><br><span class="line">&#125;<span class="comment">//放弃实现一个通用的 max 函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title function_">maxDog</span><span class="params">(Dog[] dogs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dogs == <span class="literal">null</span> || dogs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">maxDog</span> <span class="operator">=</span> dogs[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (Dog d : dogs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d.size &gt; maxDog.size) &#123; <span class="comment">//</span></span><br><span class="line">            maxDog = d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDog;</span><br><span class="line">&#125;</span><br><span class="line">基本问题是对象无法与 &gt; 进行比较。这很有道理，Java 如何知道应该使用对象的字符串表示、大小还是其他指标来进行比较呢？在 Python 或 C++中， &gt; 运算符的作用方式可以根据应用到的不同类型进行重新定义。不幸的是，Java 没有这种能力。相反，我们转向接口继承来帮助我们。</span><br></pre></td></tr></table></figure>

<p>创建一个接口,确保任何实现类，如 Dog，都包含一个比较方法,将其称为 <code>compareTo</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OurComparable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span>;</span><br><span class="line">&#125;<span class="comment">//define its behavior like so:</span></span><br><span class="line"><span class="comment">//Return -1 if this &lt; o. //Return 0 if this equals o. //Return 1 if this &gt; o.</span></span><br></pre></td></tr></table></figure>

<p>现在我们已经创建了 <code>OurComparable</code> 接口，我们可以要求我们的 Dog 类实现 <code>compareTo</code> 方法。首先，我们将 Dog 类的类头改为包含 <code>implements OurComparable</code> ，然后根据其定义的行为编写 <code>compareTo</code> 方法。</p>
<h4 id="Comparables"><a href="#Comparables" class="headerlink" title="Comparables"></a>Comparables</h4><p><code>OurComparable</code> 接口我们已经构建完成，它能够工作，但并不完美。以下是它的一些问题：</p>
<ul>
<li>尴尬的对象转换</li>
<li>我们编造了它。<ul>
<li>当前没有现有类实现 OurComparable（例如 String 等。）</li>
<li>当前没有现有类使用 OurComparable（例如，没有使用 OurComparable 的内置 max 函数）</li>
</ul>
</li>
</ul>
<p>利用一个已存在的接口，称为 <code>Comparable</code>。</p>
<p><code>Comparable&lt;T&gt;</code> 表示它接受一个泛型类型。这将帮助我们避免将对象强制转换为特定类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">现在，我们将重写 Dog 类以实现 Comparable 接口，确保更新泛型类型 `T` 为 Dog</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Dog&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Dog uddaDog)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - uddaDog.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不再使用我们亲自创建的接口 <code>OurComparable</code> ，现在使用真实的内置接口 <code>Comparable</code></p>
<img src="https://joshhug.gitbooks.io/hug61b/content/assets/comparable.png" alt="img" style="zoom:33%;" />

<h4 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h4><p>作为一个例子，狗的自然排序，正如我们之前所述，是根据体型值来定义的。如果我们想以不同于它们自然排序的方式对狗进行排序，比如按照它们名字的字母顺序排序呢？</p>
<p>Java 实现这种方式是通过使用 <code>Comparator</code> 的。由于比较器是一个对象，我们将通过在 Dog 内部编写一个实现 <code>Comparator</code> 接口的嵌套类来使用 <code>Comparator</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Dog&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Dog uddaDog)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.size - uddaDog.size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NameComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Dog&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Dog a, Dog b)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a.name.compareTo(b.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;Dog&gt; <span class="title function_">getNameComparator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NameComparator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码相当于c++的运算符重载<img src="https://joshhug.gitbooks.io/hug61b/content/assets/comparator.png" alt="img" style="zoom: 50%;" /></p>
<p>我们有一个内置的 Comparator 接口，我们可以实现它来定义自己的比较器（ <code>NameComparator</code> ， <code>SizeComparator</code> 等）</p>
<h5 id="6-2Throwing-Exceptions"><a href="#6-2Throwing-Exceptions" class="headerlink" title="6.2Throwing Exceptions"></a>6.2Throwing Exceptions</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;can&#x27;t add null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (contains(x)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    items[size] = x;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throw 关键字相当于 python里的raise</p>
<h5 id="6-3Iteration"><a href="#6-3Iteration" class="headerlink" title="6.3Iteration"></a>6.3Iteration</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (String city : s) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The above code translates to:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line">Iterator&lt;String&gt; seer = s.iterator();</span><br><span class="line"><span class="keyword">while</span> (seer.hasNext()) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> seer.next();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>Now, we can use that object to loop through all the entries in our list:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; friends = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">...</span><br><span class="line">Iterator&lt;Integer&gt; seer = friends.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (seer.hasNext()) &#123;</span><br><span class="line">System.out.println(seer.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Implementing-Iterators"><a href="#Implementing-Iterators" class="headerlink" title="Implementing Iterators"></a>Implementing Iterators</h4><p>列表接口扩展了可迭代接口，继承了抽象的 iterator()方法。（实际上，列表扩展了集合，集合又扩展了可迭代接口，但这样理解起来更简单。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;T&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，编译器检查迭代器是否有 <code>hasNext()</code> 和 <code>next()</code> 。迭代器接口明确指定了这些抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特定类将实现它们自己的接口方法的迭代行为。</p>
<p>我们将向我们的 ArrayMap 类添加通过键进行迭代的特性。首先，我们编写一个新的类，名为 ArraySetIterator，它嵌套在 ArraySet 内部：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ArraySetIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> wizPos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArraySetIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        wizPos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> wizPos &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">returnItem</span> <span class="operator">=</span> items[wizPos];</span><br><span class="line">        wizPos += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> returnItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此 ArraySetIterator 实现了一个 hasNext() 方法和一个 next() 方法，使用 wizPos 位置作为索引来跟踪其在数组中的位置。</p>
<p>现在我们有了适当的方法，我们可以使用 ArraySetIterator 遍历 ArrayMap：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArraySet&lt;Integer&gt; aset = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">aset.add(<span class="number">5</span>);</span><br><span class="line">aset.add(<span class="number">23</span>);</span><br><span class="line">aset.add(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iter = aset.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">    System.out.println(iter.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们仍然希望能够支持增强型 for 循环，以使我们的调用更简洁。因此，我们需要让 ArrayMap 实现 Iterable 接口。Iterable 接口的基本方法是 <code>iterator()</code> ，它为该类返回一个 Iterator 对象。我们只需返回我们刚刚编写的 <code>ArraySetIterator</code> 的一个实例即可！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArraySetIterator</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以使用增强型 for 循环与我们的 <code>ArrraySet</code> !</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArraySet&lt;Integer&gt; aset = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : aset) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Object-Methods"><a href="#Object-Methods" class="headerlink" title="Object Methods"></a>Object Methods</h5><p>所有类都继承自根 Object 类</p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>默认的 <code>Object</code> 类的 <code>toString()</code> 方法打印对象在内存中的位置。这是一个十六进制字符串。像 Arraylist 和 java 数组这样的类有自己的 <code>toString()</code> 方法重写版本。这就是为什么，当你处理和编写 Arraylist 的测试时，错误总是以这种格式（1，2，3，4）返回列表，而不是返回内存位置。</p>
<p>对于我们自己编写的类，如 <code>ArrayDeque</code> 、 <code>LinkedListDeque</code> 等，如果我们想以可读的格式查看打印的对象，则需要提供自己的 <code>toString()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraySet</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// the next item to be added will be at position size</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArraySet</span><span class="params">()</span> &#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ```</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">returnSB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;size-<span class="number">1</span>;i+=<span class="number">1</span>)&#123;</span><br><span class="line">            returnSB.append(items[i].toStirng());</span><br><span class="line">            returnSB.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        returnSB.append(items[size-<span class="number">1</span>]);</span><br><span class="line">        returnSB.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> returnSB.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object other)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == other)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(other ==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(other.getClass()!=<span class="built_in">this</span>.getClass())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ArraySet&lt;T&gt; o = (ArraySet&lt;T&gt;)other;</span><br><span class="line">        <span class="keyword">if</span>(o.size()!=<span class="built_in">this</span>.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(T item:<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!o.contains(item))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArraySet&lt;Integer&gt; aset = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">        aset.add(<span class="number">5</span>);aset.add(<span class="number">23</span>);aset.add(<span class="number">42</span>);</span><br><span class="line">        <span class="comment">//iteration</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : aset) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//toString</span></span><br><span class="line">        System.out.println(aset);</span><br><span class="line">        <span class="comment">//equals</span></span><br><span class="line">        ArraySet&lt;Integer&gt; aset2 = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;&gt;();</span><br><span class="line">        aset2.add(<span class="number">5</span>); aset2.add(<span class="number">23</span>);aset2.add(<span class="number">42</span>);</span><br><span class="line">        System.out.println(aset.equals(aset2));System.out.println(aset.equals(<span class="literal">null</span>));</span><br><span class="line">        System.out.println(aset.equals(<span class="string">&quot;fish&quot;</span>)); System.out.println(aset.equals(aset));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>Java 中 <code>equals()</code> 和 <code>==</code> 有不同的行为。 <code>==</code> 检查两个对象是否实际上是同一个内存中的对象。记住，按值传递！ <code>==</code> 检查两个盒子是否包含相同的东西。对于原始类型，这意味着检查值是否相等。对于对象，这意味着检查地址&#x2F;指针是否相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Doge</span> <span class="variable">fido</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doge</span>(<span class="number">5</span>, <span class="string">&quot;Fido&quot;</span>);</span><br><span class="line">      <span class="type">Doge</span> <span class="variable">doggo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doge</span>(<span class="number">6</span>, <span class="string">&quot;Doggo&quot;</span>);</span><br><span class="line">      <span class="type">Doge</span> <span class="variable">fidoTwin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doge</span>(<span class="number">5</span>, <span class="string">&quot;Fido&quot;</span>);</span><br><span class="line">      <span class="type">Doge</span> <span class="variable">fidoRealTwin</span> <span class="operator">=</span> fido;</span><br><span class="line">      </span><br><span class="line">fido 和 fidoTwin 不被视为 == ，因为它们指向不同的对象。</span><br></pre></td></tr></table></figure>

<h4 id="equals-Object-o"><a href="#equals-Object-o" class="headerlink" title="equals(Object o)"></a><code>equals(Object o)</code></h4><p>是 Object 中的一个方法，默认情况下它像 &#x3D;&#x3D; 一样工作，检查 this 的内存地址是否与 o 相同。然而，我们可以重写它来定义我们想要的任何相等性。例如，对于两个 ArrayList 被认为是相等的，它们只需要具有相同顺序的相同元素即可。</p>
<p>Java 中 equals 方法的规则：当重写一个 <code>.equals()</code> 方法时，有时可能比看起来更复杂。在实现您的 <code>.equals()</code> 方法时，以下是一些需要遵守的规则：</p>
<p>1.) <code>equals</code> 必须是一个等价关系</p>
<ul>
<li><strong>reflexive</strong>自反: <code>x.equals(x)</code> 为真</li>
<li><strong>symmetric</strong>对称: <code>x.equals(y)</code> if and only if <code>y.equals(x)</code></li>
<li><strong>transitive</strong>: 及物： <code>x.equals(y)</code> 和 <code>y.equals(z)</code> 蕴含 <code>x.equals(z)</code></li>
</ul>
<p>2.) 必须传递一个对象参数，以覆盖原始的 <code>.equals()</code> 方法</p>
<p>3.) 如果 <code>x.equals(y)</code> ，则只要 <code>x</code> 和 <code>y</code> 保持不变： <code>x</code> 必须继续等于 <code>y</code></p>
<p>4.) 对于 null， <code>x.equals(null)</code> 必须为假</p>
<h5 id="Efficient-Programming"><a href="#Efficient-Programming" class="headerlink" title="Efficient Programming"></a>Efficient Programming</h5><p>编写一个使用链表作为其底层数据结构的 Stack 类。您只需要实现一个函数：push(Item x)。确保使用”Item”作为泛型类型使该类通用！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)使用拓展 <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtensionStack</span>&lt;Item&gt; <span class="keyword">extends</span> <span class="title class_">LinkedList</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Item x)</span>&#123;</span><br><span class="line">        add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>)使用委托 创建一个链表对象并调用其方法以实现其目标 </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegationStack</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Item&gt; L = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Item&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Item x)</span> &#123;</span><br><span class="line">        L.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>)这种方法与之前的方法类似，除了它可以使用实现 List 接口的任何类（如 LinkedList、ArrayList 等）。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackAdapter</span>&lt;Item&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> List L;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StackAdapter</span><span class="params">(List&lt;Item&gt; worker)</span>&#123;</span><br><span class="line">        L = worker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Item x)</span>&#123;</span><br><span class="line">        L.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//委托是通过传递一个类来完成的，而扩展被定义为继承</span></span><br></pre></td></tr></table></figure>



<h5 id="不相交集合（并查集）"><a href="#不相交集合（并查集）" class="headerlink" title="不相交集合（并查集）"></a>不相交集合（并查集）</h5><p>假设我们有四个元素，我们将它们称为 A、B、C、D。一开始，每个元素都在自己的集合中。<img src="https://joshhug.gitbooks.io/hug61b/content/chap9/intro1_resized.png" alt="img" style="zoom:25%;" /></p>
<p>在调用 <code>connect(A, B)</code> 后<img src="https://joshhug.gitbooks.io/hug61b/content/chap9/intro2_resized.png" alt="img" style="zoom:25%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isConnected(A, B) -&gt; <span class="literal">true</span></span><br><span class="line"><span class="title function_">isConnected</span><span class="params">(A, C)</span> -&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>我们正式定义我们的 DisjointSets:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">connect</span> <span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Quick-Find"><a href="#Quick-Find" class="headerlink" title="Quick Find"></a>Quick Find</h4><p>考虑使用一个整数数组作为另一种方法。····数组索引代表我们集合的元素。索引处的值是该集合所属的编号。</p>
<p>例如：表示 <code>&#123;0, 1, 2, 4&#125;, &#123;3, 5&#125;, &#123;6&#125;</code> 为<img src="https://joshhug.gitbooks.io/hug61b/content/chap9/9.2.1.png" alt="img" style="zoom:25%;" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickFindDS</span> <span class="keyword">implements</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line">    <span class="comment">/* Θ(N) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickFindDS</span><span class="params">(<span class="type">int</span> N)</span>&#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* need to iterate through the array =&gt; Θ(N) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> id[p];</span><br><span class="line">        <span class="type">int</span> <span class="variable">qid</span> <span class="operator">=</span> id[q];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; id.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i] == pid)&#123;</span><br><span class="line">                id[i] = qid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Θ(1) */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (id[p] == id[q]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Quick-Union"><a href="#Quick-Union" class="headerlink" title="Quick Union"></a>Quick Union</h4><p>我们给每个项目分配其父项的索引。如果一个项目没有父项，那么它是一个’root’，我们给它分配一个负值。例如，我们表示 <code>&#123;0, 1, 2, 4&#125;, &#123;3, 5&#125;, &#123;6&#125;</code> 为：：<img src="https://joshhug.gitbooks.io/hug61b/content/chap9/9.3.1.png" alt="img" style="zoom: 25%;" /></p>
<p>对于 QuickUnion，我们定义一个辅助函数 <code>find(int item)</code> ，它返回树 <code>item</code> 所在的根。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickUnionDS</span> <span class="keyword">implements</span> <span class="title class_">DisjointSets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QuickUnionDS</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (parent[p] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            p = parent[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> j= find(q);</span><br><span class="line">        parent[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Weighted-Quick-Union-WQU-加权快速并查集"><a href="#Weighted-Quick-Union-WQU-加权快速并查集" class="headerlink" title="Weighted Quick Union (WQU)加权快速并查集"></a>Weighted Quick Union (WQU)加权快速并查集</h4><p>新规则：每次我们调用 <code>connect</code> 时，我们总是将较小树的根连接到较大树上。遵循此规则将使树的最大高度为 <strong>log<em>N</em></strong> ，其中 N 是我们并查集中元素的数量。<img src="https://joshhug.gitbooks.io/hug61b/content/chap9/9.4.2.png" alt="img" style="zoom:25%;" />选第2种</p>
<h4 id="Weighted-Quick-Union-with-Path-Compression"><a href="#Weighted-Quick-Union-with-Path-Compression" class="headerlink" title="Weighted Quick Union with Path Compression"></a>Weighted Quick Union with Path Compression</h4><p>路径压缩的优化思想是：</p>
<ul>
<li>在 Find 操作中，将查找路径上的所有节点直接连接到根节点。</li>
<li>这样可以进一步减少树的高度，使得后续的 Find 操作更快。</li>
</ul>
<h4 id="Binary-Search二分查找"><a href="#Binary-Search二分查找" class="headerlink" title="Binary Search二分查找"></a>Binary Search二分查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(String[] sorts,String x,<span class="type">int</span> lo,<span class="type">int</span> hi)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lo&gt;hi) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> m=(lo+hi)/<span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> cmp=x.compareTo(sorted[m]);</span><br><span class="line">	<span class="keyword">if</span>(cmp&lt;<span class="number">0</span>) <span class="keyword">return</span> binarySearch(sorts,x,lo,m-<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)<span class="keyword">return</span> binarySearch(sorts,x,m+<span class="number">1</span>,hi);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：Θ(log<em>N</em>)</p>
<h4 id="Merge-Sort归并排序"><a href="#Merge-Sort归并排序" class="headerlink" title="Merge Sort归并排序"></a>Merge Sort归并排序</h4><p>runtime: N logN</p>
<h5 id="ADTs"><a href="#ADTs" class="headerlink" title="ADTs"></a>ADTs</h5><p>几个有用的 ADT：</p>
<ul>
<li>非交集集合，映射，集合，列表。</li>
<li>Java 提供了 Map、Set、List 接口，以及几个实现。</li>
</ul>
<h5 id="Trees"><a href="#Trees" class="headerlink" title="Trees"></a>Trees</h5><h4 id="Binary-Search-Trees"><a href="#Binary-Search-Trees" class="headerlink" title="Binary Search Trees"></a>Binary Search Trees</h4><ul>
<li>每个左子树中的键都小于 X 的键。每个右子树中的键都大于 X 的键。</li>
</ul>
<p>约束：任意两个节点之间只有一条路径。   传递性：p&lt;q and q&lt;r imply p&lt;r  反对称性： Exactly one of p&lt;q and q&lt;p are true</p>
<p>不能有重复，比如2个dog</p>
<p>这里是我们将在本模块中使用的二叉搜索树（BST）类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">BST</span>&lt;Key&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Key key;</span><br><span class="line">    <span class="keyword">private</span> BST left;</span><br><span class="line">    <span class="keyword">private</span> BST right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BST</span><span class="params">(Key key, BST left, BST Right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BST</span><span class="params">(Key key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Binary-Search-Tree-Operations"><a href="#Binary-Search-Tree-Operations" class="headerlink" title="Binary Search Tree Operations"></a>Binary Search Tree Operations</h4><p>Search</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BST <span class="title function_">find</span><span class="params">(BST T,Key sk)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sk.equals(T.key))&#123;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sk&lt; T.key)&#123;</span><br><span class="line">        <span class="keyword">return</span> find(T.left,sk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> find(T.right,sk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Insert</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BST <span class="title function_">insert</span><span class="params">(BST T,Key ik)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BST</span>(ik);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(ik&lt;T.key)&#123;</span><br><span class="line">        T.left=insert(T.left,ik);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ik&gt;T.key)&#123;</span><br><span class="line">        T.right=insert(T.right,ik);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Delete</p>
<p>让我们将这个问题分解为三个类别：</p>
<ul>
<li>我们要删除的节点没有子节点 ：直接删</li>
<li>有 1 个子节点 ：子承父业</li>
<li>有 2 个子节点 ：选择一个新的节点来替换被删除的节点。只需取左子树最右边的节点或右子树最左边的节点即可（称为 Hibbard 删除）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Balanced-Search-Trees"><a href="#Balanced-Search-Trees" class="headerlink" title="Balanced Search Trees"></a>Balanced Search Trees</h5><p><em>Worst case:</em> Θ(N)Θ(<em>N</em>)</p>
<p><em>Best-case:</em> Θ(logN)Θ(log<em>N</em>) (where <em>N</em> is number of nodes in the tree)</p>
<p>Some terminology for BST performance:</p>
<ul>
<li><strong>depth</strong>: the number of links between a node and the root.</li>
<li><strong>height</strong>: the lowest depth of a tree.</li>
<li><strong>average depth</strong>: average of the total depths in the tree.</li>
</ul>
<p>The <strong>height</strong> of the tree determines the worst-case runtime, because in the worst case the node we are looking for is at the bottom of the tree.</p>
<p>The <strong>average depth</strong> determines the average-case runtime.</p>
<h5 id="B-Trees"><a href="#B-Trees" class="headerlink" title="B-Trees"></a>B-Trees</h5><h4 id="Insertion-Process-插入过程"><a href="#Insertion-Process-插入过程" class="headerlink" title="Insertion Process 插入过程"></a>Insertion Process 插入过程</h4><p>The process of adding a node to a 2-3-4 tree is:<br>添加节点到 2-3-4 树的过程是：</p>
<ol>
<li>我们仍然总是插入到叶节点，所以取要插入的节点并带着它遍历树，根据要插入的节点是否大于或小于每个节点中的项来决定是向左还是向右移动。</li>
<li>在将节点添加到叶节点后，如果新节点有 4 个节点，则弹出中间左节点并相应地重新排列子节点。</li>
<li>如果这导致父节点有 4 个节点，那么再次弹出中间左节点，相应地重新排列子节点。</li>
<li>重复此过程，直到父节点可以容纳或到达根节点。<br>对于 2-3 树，执行相同的过程，除了在 3 元素节点中向上推送中间节点。</li>
</ol>
<h5 id="B-Tree-invariants"><a href="#B-Tree-invariants" class="headerlink" title="B-Tree invariants"></a>B-Tree invariants</h5><p>B 树具有以下有用的不变性：</p>
<ul>
<li>所有叶子必须与源头保持相同的距离。</li>
<li>一个包含 <em>k</em> 项的非叶节点必须恰好有 <em>k</em>+1 个子节点。</li>
</ul>
<h4 id="runtime-总运行时间是-O-logN"><a href="#runtime-总运行时间是-O-logN" class="headerlink" title="runtime:总运行时间是 O(logN)"></a>runtime:总运行时间是 <em>O</em>(log<em>N</em>)</h4><h5 id="Rotating-Trees"><a href="#Rotating-Trees" class="headerlink" title="Rotating Trees"></a>Rotating Trees</h5><p>旋转的正式定义是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rotateLeft(G): Let x be the right child of G. Make G the new left child of x.</span><br><span class="line">rotateRight(G): Let x be the left child of G. Make G the new right child of x.</span><br></pre></td></tr></table></figure>

<p>以下是节点 G 左旋操作发生情况的图形描述：<br>G 的右子树 P 与 G 合并，并带上其子树。然后 P 将其左子树传递给 G，G 向下移动到左边成为 P 的左子树。</p>
<p>相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">rotateRight</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.left;</span><br><span class="line">    h.left = x.right;</span><br><span class="line">    x.right = h;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">rotateLeft</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> h.right;</span><br><span class="line">    h.right = x.left;</span><br><span class="line">    x.left = h;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Red-Black-Trees"><a href="#Red-Black-Trees" class="headerlink" title="Red-Black Trees"></a>Red-Black Trees</h5><p>任意选择将左元素作为右元素的子元素。这导致了一棵左倾树。我们通过将其染成红色来证明链接是一个粘合链接。正常链接是黑色的。因此，我们称这些结构为左倾红黑树（LLRB）。</p>
<h5 id="左倾红黑树与-2-3-树一一对应。每个-2-3-树都有一个唯一的左倾红黑树与之关联。至于-2-3-4-树，它们与标准红黑树保持对应关系。"><a href="#左倾红黑树与-2-3-树一一对应。每个-2-3-树都有一个唯一的左倾红黑树与之关联。至于-2-3-4-树，它们与标准红黑树保持对应关系。" class="headerlink" title="左倾红黑树与 2-3 树一一对应。每个 2-3 树都有一个唯一的左倾红黑树与之关联。至于 2-3-4 树，它们与标准红黑树保持对应关系。"></a>左倾红黑树与 2-3 树一一对应。每个 2-3 树都有一个唯一的左倾红黑树与之关联。至于 2-3-4 树，它们与标准红黑树保持对应关系。</h5><h4 id="Properties-of-LLRB’s"><a href="#Properties-of-LLRB’s" class="headerlink" title="Properties of LLRB’s"></a>Properties of LLRB’s</h4><p>LLRB 的属性如下：</p>
<ul>
<li>1-1 对应于 2-3 树。</li>
<li>没有节点有 2 个红色链接。</li>
<li>没有红色右链。</li>
<li>每条从根到叶子的路径都有相同数量的黑色链接（因为 2-3 树到每个叶子的链接数量相同）。</li>
<li>高度不超过对应 2-3 树 2 倍的高度。</li>
</ul>
<p>Here is a summary of all the operations:<br>When inserting: Use a red link.<br>If there is aright leaning “3-node”, we have a Left Leaning Violation</p>
<ul>
<li><ul>
<li>Rotate left the appropriate node to fix.</li>
</ul>
</li>
<li>If there are two consecutive left links, we have an incorrect 4 Node Violation!<ul>
<li>Rotate right the appropriate node to fix.</li>
</ul>
</li>
<li>If there are any nodes with two red children, we have a temporary 4 Node.<ul>
<li>Color flip the node to emulate the split operation.<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240520123138/examples-of-red-black-tree-22.webp" alt="examples-of-red-black-tree-22" style="zoom: 33%;" /></li>
</ul>
</li>
</ul>
<h4 id="Properties-of-Red-Black-Trees"><a href="#Properties-of-Red-Black-Trees" class="headerlink" title="Properties of Red-Black Trees"></a>Properties of Red-Black Trees</h4><p>A Red-Black Tree have the following properties:</p>
<p>1.Node Color: Each node is either red or black.<br>2.Root Property: The root of the tree is always black.<br>3.Red Property: Red nodes cannot have red children (no two consecutive red nodes on any path).<br>4.Black Property: Every path from a node to its descendant null nodes (leaves) has the same number of black nodes.<br>5.Leaf Property: All leaves (NIL nodes) are black.</p>
<h4 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h4><p>Because a left-leaning red-black tree has a 1-1 correspondence with a 2-3 tree and will always remain within 2x the height of its 2-3 tree, the runtimes of the operations will take log<em>N</em> time.</p>
<p>Here’s the abstracted code for insertion into a LLRB:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">put</span><span class="params">(Node h, Key key, Value val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="literal">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, val, RED); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> key.compareTo(h.key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)      &#123; h.left  = put(h.left,  key, val); &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123; h.right = put(h.right, key, val); &#125;</span><br><span class="line">    <span class="keyword">else</span>              &#123; h.val   = val;                    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRed(h.right) &amp;&amp; !isRed(h.left))      &#123; h = rotateLeft(h);  &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.left.left)) &#123; h = rotateRight(h); &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRed(h.left)  &amp;&amp;  isRed(h.right))     &#123; flipColors(h);      &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h4><p>用数组来代替BST,BT,LLRB，index代表数据，true&#x2F;false代表是否被存储</p>
<ul>
<li>如何适用除数字以外的其他数据？——用 ASCII &#x2F; Unicode</li>
<li>不可避免的冲突？——内部使用 List 结构    取模压空间</li>
<li>内存开销巨大？运行时不稳定？——使用限定大小且动态增长的数组！同时进一步改进我们的 Hashcode!</li>
</ul>
<h4 id="Properties-of-HashCodes"><a href="#Properties-of-HashCodes" class="headerlink" title="Properties of HashCodes"></a>Properties of HashCodes</h4><ol>
<li>It must be an Integer</li>
<li>If we run <code>.hashCode()</code> on an object twice, it should return the <strong>same</strong> number</li>
<li>Two objects that are considered <code>.equal()</code> must have the same hash code.</li>
</ol>
<h5 id="1-哈希表的基本工作原理"><a href="#1-哈希表的基本工作原理" class="headerlink" title="1. 哈希表的基本工作原理"></a><strong>1. 哈希表的基本工作原理</strong></h5><ol>
<li>哈希函数转换<ul>
<li>输入项（如键值对）通过<strong>哈希函数</strong>（<code>hashcode</code>）转换为整数。</li>
<li>通过<strong>取模运算</strong>（<code>%</code>）将该整数映射到哈希表数组的有效索引位置。</li>
</ul>
</li>
<li>冲突处理<ul>
<li>若目标索引为空，创建新链表并将输入项加入其中。</li>
<li>若索引已存在链表，则遍历链表检查重复项。若无重复，将输入项追加至链表末尾。</li>
</ul>
</li>
<li>查询逻辑<ul>
<li>计算目标索引，遍历对应链表查找指定项，时间复杂度取决于链表长度。</li>
</ul>
</li>
</ol>
<hr>
<h5 id="2-处理性能问题"><a href="#2-处理性能问题" class="headerlink" title="2. 处理性能问题"></a><strong>2. 处理性能问题</strong></h5><p><strong>关键挑战</strong>：哈希冲突导致的链表长度不均，影响操作效率。</p>
<table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>表现</strong></th>
<th><strong>时间复杂度</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>最佳情况</strong></td>
<td>所有项均匀分布在 <code>M</code> 个桶中，每桶含 <code>N/M</code> 项</td>
<td><code>Θ(1)</code>（均摊）</td>
</tr>
<tr>
<td><strong>最坏情况</strong></td>
<td>所有项堆积到同一桶中，形成长度为 <code>N</code> 的链表</td>
<td><code>Θ(N)</code>（退化为链表）</td>
</tr>
</tbody></table>
<p><strong>优化策略</strong>：</p>
<ol>
<li><p>动态扩容哈希表</p>
<ul>
<li><p><strong>负载因子（Load Factor）</strong>：定义为 <code>N/M</code>（项数&#x2F;桶数），代表哈希表的空间利用率。</p>
</li>
<li><p>扩容阈值</p>
<p>：当负载因子超过预设值（如0.75），触发以下操作：</p>
<ul>
<li>创建新哈希表，桶数翻倍（<code>2M</code>）。</li>
<li>遍历旧表所有项，按新表大小重新计算索引并迁移（因取模结果可能变化）。</li>
</ul>
</li>
<li><p><strong>扩容耗时</strong>：<code>Θ(N)</code>（需逐项迁移，但插入新表时无需查重，直接链表头部追加，单次操作为 <code>Θ(1)</code>）。</p>
</li>
</ul>
</li>
<li><p>优化哈希码设计</p>
<ul>
<li><strong>目标</strong>：确保不同输入项生成尽可能随机的哈希码，减少冲突概率。</li>
<li>实践建议：<ul>
<li>使用<strong>小质数</strong>作为哈希计算基数（如31），避免因整数溢出导致的系统性冲突。</li>
<li>避免依赖局部特征（如字符串末尾字符），防止相似输入哈希码趋同。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="Heaps"><a href="#Heaps" class="headerlink" title="Heaps"></a>Heaps</h5><p>堆的基本定义如下：</p>
<ul>
<li>首先是一颗<strong>完整的</strong>二叉树</li>
<li>每个结点的值<strong>小于等于</strong>其两个子节点的值(当然在求 max 的情况下反过来即可)</li>
<li>所有结点尽量<strong>左倾</strong></li>
</ul>
<p><img src="https://joshhug.gitbooks.io/hug61b/content/assets/heap-13.2.1.png" alt="img"></p>
<p>如上图所示：红色的即为不合规的堆<br>我们关心优先级队列的三种方法是 <code>add</code> ， <code>getSmallest</code> 和 <code>removeSmallest</code> 。</p>
<ul>
<li>add: Add to the end of heap temporarily. Swim up the hierarchy to the proper place.<ul>
<li>Swimming involves swapping nodes if child &lt; parent</li>
</ul>
</li>
<li><code>getSmallest</code>: Return the root of the heap (This is guaranteed to be the minimum by our <em>min-heap</em> property</li>
<li>removeSmallest: Swap the last item in the heap into the root. Sink down the hierarchy to the proper place.<ul>
<li>Sinking involves swapping nodes if parent &gt; child. Swap with the smallest child to preserve <em>min-heap</em> property</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>Methods</th>
<th>Ordered Array</th>
<th>Bushy BST</th>
<th>Hash Table</th>
<th>Heap</th>
</tr>
</thead>
<tbody><tr>
<td><code>add</code></td>
<td>Θ(<em>N</em>)</td>
<td>Θ(log<em>N</em>)</td>
<td>Θ(1)</td>
<td>Θ(log<em>N</em>)</td>
</tr>
<tr>
<td><code>getSmallest</code></td>
<td>Θ(1)</td>
<td>Θ(log<em>N</em>)</td>
<td>Θ(<em>N</em>)</td>
<td>Θ(1)</td>
</tr>
<tr>
<td><code>removeSmallest</code></td>
<td>Θ(<em>N</em>)</td>
<td>Θ(log<em>N</em>)</td>
<td>Θ(<em>N</em>)</td>
<td>Θ(log<em>N</em>)</td>
</tr>
</tbody></table>
<h5 id="Tree-Traversal"><a href="#Tree-Traversal" class="headerlink" title="Tree Traversal"></a>Tree Traversal</h5><p>has one natural way to iterate through it:</p>
<ol>
<li>Level order traversal.</li>
<li>Depth-First traversals –– of which there are three: pre-order, in-order and post-order.</li>
</ol>
<h4 id="Level-Order-Traversal（是一种BFS"><a href="#Level-Order-Traversal（是一种BFS" class="headerlink" title="Level Order Traversal（是一种BFS)"></a>Level Order Traversal（是一种BFS)</h4><p>一层一层遍历，从第 0 层(即根节点)开始，一步步向后推·······</p>
<p>得到的结果是： <code>D B F A C E G</code></p>
<h4 id="Depth-First-traversals-––-of-which-there-are-three-pre-order-in-order-and-post-order-（DFS）"><a href="#Depth-First-traversals-––-of-which-there-are-three-pre-order-in-order-and-post-order-（DFS）" class="headerlink" title="Depth-First traversals –– of which there are three: pre-order, in-order and post-order.（DFS）"></a>Depth-First traversals –– of which there are three: pre-order, in-order and post-order.（DFS）</h4><p>Pre-order Traversal 上， 左右</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">preOrder(BSTNode x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    print(x.key)</span><br><span class="line">    preOrder(x.left)</span><br><span class="line">    preOrder(x.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In-order Traversal 左中右</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inOrder(BSTNode x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;    </span><br><span class="line">    inOrder(x.left)</span><br><span class="line">    print(x.key)</span><br><span class="line">    inOrder(x.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Post-order Traversal 左右中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postOrder(BSTNode x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">null</span>) <span class="keyword">return</span>;    </span><br><span class="line">    postOrder(x.left)</span><br><span class="line">    postOrder(x.right)</span><br><span class="line">    print(x.key)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>DFS伪代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mark s  <span class="comment">// i.e., remember that you visited s already</span></span><br><span class="line"><span class="keyword">if</span> (s == t):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> <span class="title function_">unmarked_neighbors</span>(s): <span class="comment">// if a neighbor is marked, ignore!</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">isconnected</span>(child, t):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>BFS伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Initialize the fringe (a queue with the starting vertex) and mark that vertex.</span><br><span class="line">Repeat until fringe is empty:</span><br><span class="line">Remove vertex v from the fringe.</span><br><span class="line">For each unmarked neighbor n of v:</span><br><span class="line">Mark n.</span><br><span class="line">Add n to fringe.</span><br><span class="line">Set edgeTo[n] = v.</span><br><span class="line">Set distTo[n] = distTo[v] + 1.</span><br></pre></td></tr></table></figure>

<p>A <em>fringe</em> is just a term we use for the data structure we are using to store the nodes on the frontier of our traversal’s discovery process (the next nodes it is waiting to look at). For BFS, we use a queue for our fringe.</p>
<p><code>edgeTo[...]</code> is a map that helps us track how we got to node <code>n</code>; we got to it by following the edge from <code>v</code> to to <code>n</code>.</p>
<p><code>distTo[...]</code> is a map that helps us track how far <code>n</code> is from the starting vertex. Assuming that each edge is worth a distance of <code>1</code>, then the distance to <code>n</code> is just one more than the distance to get to <code>v</code>. Why? We can use the way we know how to get to <code>v</code>, then pay one more to arrive at <code>n</code> via the edge that necessarily exists between <code>v</code> and <code>n</code> (it must exist since in the <code>for</code> loop header, <code>n</code> is defined as a neighbor of <code>v</code>).</p>
<h4 id="Representing-Graphs"><a href="#Representing-Graphs" class="headerlink" title="Representing Graphs"></a>Representing Graphs</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> V)</span>:               <span class="comment">// Create empty graph with v vertices</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span>: <span class="comment">// add an edge v-w</span></span><br><span class="line">  Iterable&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> v)</span>:      <span class="comment">// vertices adjacent to v</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">V</span><span class="params">()</span>:                           <span class="comment">// number of vertices</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">E</span><span class="params">()</span>:                           <span class="comment">// number of edges</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>接下来，我们将讨论可以用来表示我们的图的基本数据结构。</p>
<p><strong>Adjacency Matrix 邻接矩阵</strong><br>我们可以通过使用二维数组来实现这一点。如果连接顶点 <code>s</code> 到 <code>t</code> 的边对应单元格是 <code>1</code> （表示 <code>true</code> ），则存在一条边连接顶点 <code>s</code> 到 <code>t</code> 。注意，如果图是无向的，邻接矩阵将对角线（从左上角到底右角）将是对称的。 </p>
<p><strong>Edge Sets 边集</strong><br>另一种方法是存储所有边的单个集合。</p>
<p><strong>Adjacency Lists 邻接表</strong></p>
<p>第三种方法是维护一个由顶点编号索引的列表数组。如果从 <code>s</code> 到 <code>t</code> 存在边，则数组索引 <code>s</code> 的列表将包含 <code>t</code> 。</p>
<h5 id="Shortest-Paths"><a href="#Shortest-Paths" class="headerlink" title="Shortest Paths"></a>Shortest Paths</h5><h4 id="19-2-dijkstra"><a href="#19-2-dijkstra" class="headerlink" title="19.2 dijkstra"></a>19.2 dijkstra</h4><p>目的：找最短路径树</p>
<p>步骤：</p>
<ol>
<li>创建一个优先队列。</li>
<li>将 s<em>s</em> 添加到优先队列中，优先级为<strong>0</strong> 。将所有其他顶点添加到优先队列中，优先级为 <strong>∞</strong> 。</li>
<li>当优先队列不为空时：从优先队列中弹出一个顶点，并<strong>松驰</strong>从这个顶点出发的所有边。</li>
</ol>
<p>松弛，即对当前顶点的所有边进行一个距离的检查，如果当前顶点的距离加上该边的权重小于该边另一个顶点的距离，则更新之。这个计算潜在距离、检查是否更好并可能更新的整个过程被称为放松(relax)。</p>
<p>伪代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def <span class="title function_">dijkstras</span><span class="params">(source)</span>:</span><br><span class="line">    PQ.add(source, <span class="number">0</span>)</span><br><span class="line">    For all other vertices, v, PQ.add(v, infinity)</span><br><span class="line">    <span class="keyword">while</span> PQ is not empty:</span><br><span class="line">        p = PQ.removeSmallest()</span><br><span class="line">        relax(all edges from p)</span><br><span class="line">def <span class="title function_">relax</span><span class="params">(edge p,q)</span>:</span><br><span class="line">   <span class="keyword">if</span> q is <span class="title function_">visited</span> <span class="params">(i.e., q is not in PQ)</span>:</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> distTo[p] + weight(edge) &lt; distTo[q]:</span><br><span class="line">       distTo[q] = distTo[p] + w</span><br><span class="line">       edgeTo[q] = p</span><br><span class="line">       PQ.changePriority(q, distTo[q])</span><br></pre></td></tr></table></figure>

<h5 id="19-3-A"><a href="#19-3-A" class="headerlink" title="19.3 A*"></a>19.3 A*</h5><p>指定源点，指定目标点，求源点到达目标点的最短距离</p>
<p>直观上，Dijkstra 算法从源节点开始（想象源节点是圆的中心。）然后，Dijkstra 算法现在围绕这个点绘制同心圆，半径逐渐增大，并“扫过”这些圆，捕获点。所以，迪杰斯特拉首先访问的是离源点最近的城市，然后是下一个最近的城市。迪杰斯特拉所做的是首先访问所有距离为 1 个单位的城市，然后是距离为 2 个单位的城市，依此类推。</p>
<p>教材演示<a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/177bRUTdCa60fjExdr9eO04NHm0MRfPtCzvEup1iMccM/edit#slide=id.g771336078_0_180">https://docs.google.com/presentation/d/177bRUTdCa60fjExdr9eO04NHm0MRfPtCzvEup1iMccM/edit#slide=id.g771336078_0_180</a></p>
<p>让我们稍微修改一下 Dijkstra 算法。在 Dijkstra 算法中，我们使用了 bestKnownDistToV 作为算法中的优先级。这次，我们将使用 +bestKnownDistToV+<strong>estimateFromVToGoal</strong> 作为我们的启发式函数。</p>
<p>在其他地方学的是：在djikstra 源点-&gt;当前点 基础上 变为 源点-&gt;当前点(真实距离) +当前点 -&gt;目标点(<strong>预估距离</strong>)，而我们要写个<strong>预估函数</strong>，在堆中根据 这个 来排序。</p>
<p>预估函数 要保证 ≤x-&gt;终点真实最短距离。有向图不好估计，一般是二维网络直接<strong>曼哈顿距离</strong></p>
<p>|x1-x2|+|y1-y2|（只能上下左右情况）     </p>
<p>对角线距离 ： max{|x1-x2|,|y1-y2|}（能走斜线情况）</p>
<h5 id="Minimum-Spanning-Trees"><a href="#Minimum-Spanning-Trees" class="headerlink" title="Minimum Spanning Trees"></a>Minimum Spanning Trees</h5><h4 id="20-1MSTs-and-Cut-Property"><a href="#20-1MSTs-and-Cut-Property" class="headerlink" title="20.1MSTs and Cut Property"></a>20.1MSTs and Cut Property</h4><p><strong>cut</strong>: 将图中的节点分配到两个非空集合（即我们将每个节点分配到第一集合或第二集合）的分配。</p>
<p><strong>crossing edge</strong>:连接一个集合中的节点到另一个集合中的节点的边</p>
<p><strong>Cut Property</strong>: given any cut, the minimum weight crossing edge is in the MST.</p>
<h4 id="20-2-Prim-and-Kruskal"><a href="#20-2-Prim-and-Kruskal" class="headerlink" title="20.2 Prim and Kruskal"></a>20.2 Prim and Kruskal</h4><p>(对不起这部分用了c++的板子写，后面会改回来的)</p>
<h4 id="1-Prim算法（朴素版）-→-“出圈法”"><a href="#1-Prim算法（朴素版）-→-“出圈法”" class="headerlink" title="1. Prim算法（朴素版） → “出圈法”"></a>1. <strong>Prim算法（朴素版） → “出圈法”</strong></h4><ul>
<li><p><strong>核心逻辑</strong>：每次从当前生成树的”外圈”（未加入的顶点集合）中，选择距离生成树最近的顶点加入。</p>
</li>
<li><p><strong>操作特点</strong>：通过遍历所有未加入顶点，找到与生成树相连的最小权重边（即”出圈”操作）。</p>
<p>强调从”外圈”顶点中逐步选出最近的顶点加入生成树。</p>
</li>
<li><p>时间复杂度：O(n²) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">prim 朴素</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1e9</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,a,b,c,ans,cnt;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">5010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w;&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line"><span class="type">int</span> d[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prim</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)d[i]=inf;</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;d[u]&gt;d[j])u=j;</span><br><span class="line">        vis[u]=<span class="number">1</span>;<span class="comment">//标记u已出圈</span></span><br><span class="line">        ans+=d[u];</span><br><span class="line">        <span class="keyword">if</span>(d[u]!=inf)cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed: e[u])&#123;</span><br><span class="line">            <span class="type">int</span> v=ed.v,w=ed.w;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;w)d[v]=w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt==n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(&#123;b,c&#125;);</span><br><span class="line">        e[b].<span class="built_in">push_back</span>(&#123;a,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">prim</span>(<span class="number">1</span>))<span class="built_in">puts</span>(<span class="string">&quot;orz&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-Prim算法（堆优化版）-→-“出队法”"><a href="#2-Prim算法（堆优化版）-→-“出队法”" class="headerlink" title="2. Prim算法（堆优化版） → “出队法”"></a>2. <strong>Prim算法（堆优化版） → “出队法”</strong></h4><ul>
<li><p><strong>核心逻辑</strong>：用优先队列（堆）维护候选边，每次直接取出堆顶的最小权重边。</p>
</li>
<li><p><strong>操作特点</strong>：通过堆快速获取最小边，避免遍历所有顶点（即”出队”操作）。</p>
<p>强调从优先队列中不断”出队”最小边。</p>
</li>
<li><p>时间复杂度：O(m log m)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">prim -heap</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1e9</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a,b,c,ans,cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w;&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line"><span class="type">int</span> d[N],vis[N];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prim</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)d[i]=inf;</span><br><span class="line">    d[s]=<span class="number">0</span>;q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">top</span>().second;q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u])<span class="keyword">continue</span>;<span class="comment">//再出队跳过</span></span><br><span class="line">        vis[u]=<span class="number">1</span>;<span class="comment">//标记u已出队</span></span><br><span class="line">        ans+=d[u];cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed :e[u])&#123;</span><br><span class="line">            <span class="type">int</span> v=ed.v,w=ed.w;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;w)&#123;</span><br><span class="line">                d[v]=w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;-d[v],v&#125;);<span class="comment">//大根堆</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt==n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">      cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">      e[a].<span class="built_in">push_back</span>(&#123;b,c&#125;);</span><br><span class="line">      e[b].<span class="built_in">push_back</span>(&#123;a,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">prim</span>(<span class="number">1</span>))<span class="built_in">puts</span>(<span class="string">&quot;orz&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-Kruskal算法-→-“加边法”"><a href="#3-Kruskal算法-→-“加边法”" class="headerlink" title="3. Kruskal算法 → “加边法”"></a>3. <strong>Kruskal算法 → “加边法”</strong></h4><ul>
<li><p><strong>核心逻辑</strong>：按边权重从小到大排序，依次选择不形成环的边加入生成树。</p>
</li>
<li><p><strong>操作特点</strong>：逐步”添加边”到生成树中，直到所有顶点连通。</p>
<p>强调按权重从小到大”加边”的过程。</p>
</li>
<li><p>时间复杂度：O(m log m)</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Kruskal</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200006</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> edge &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;<span class="keyword">return</span> w&lt; t.w;&#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> fa[N],ans,cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(e,e+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">find</span>(e[i].u);</span><br><span class="line">        <span class="type">int</span> y=<span class="built_in">find</span>(e[i].v);</span><br><span class="line">        <span class="keyword">if</span>(x!=y)&#123;</span><br><span class="line">            fa[x]=y;</span><br><span class="line">            ans+=e[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt==n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">kruskal</span>())<span class="built_in">puts</span>(<span class="string">&quot;orz&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://cuso41108.github.io">LST</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://cuso41108.github.io/2025/03/09/CS61Bnote/">https://cuso41108.github.io/2025/03/09/CS61Bnote/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/luffy.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/03/09/test/" title="测试文章"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">测试文章</div></div><div class="info-2"><div class="info-item-1">这是一个测试Hello Hexo! </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/luffy.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">LST</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CuSO41108/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/CuSO41108/" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1737268347@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CS61B-NOTE"><span class="toc-number">1.</span> <span class="toc-text">CS61B NOTE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Lists"><span class="toc-number">1.1.</span> <span class="toc-text">2.Lists</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">2.1</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text">引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.1.3.</span> <span class="toc-text">参数传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.1.4.</span> <span class="toc-text">数组实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-SLList"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">2.2 SLList</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-number">1.1.5.</span> <span class="toc-text">嵌套类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.6.</span> <span class="toc-text">缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.7.</span> <span class="toc-text">2.3双向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.1.8.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">2.4数组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Resizing-Arrays%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.1.9.</span> <span class="toc-text">Resizing Arrays调整数组大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1JUnit-%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.10.</span> <span class="toc-text">3.1JUnit 测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A"><span class="toc-number">1.1.11.</span> <span class="toc-text">怎么比较字符串：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%97%B6%E7%94%A8%E7%A7%81%E6%9C%89%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.12.</span> <span class="toc-text">递归时用私有辅助方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.12.1.</span> <span class="toc-text">4.1继承，实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">1.1.13.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.14.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96Override"><span class="toc-number">1.1.15.</span> <span class="toc-text">覆盖Override</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Interface-Inheritance-%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.16.</span> <span class="toc-text">Interface Inheritance 接口继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Implementation-Inheritance-%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.17.</span> <span class="toc-text">Implementation Inheritance 实现继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2Extend"><span class="toc-number">1.1.17.1.</span> <span class="toc-text">4.2Extend</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E5%8F%AF%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.17.2.</span> <span class="toc-text">构造函数不可继承:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Object-Class"><span class="toc-number">1.1.18.</span> <span class="toc-text">The Object Class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B1%8F%E9%9A%9C"><span class="toc-number">1.1.19.</span> <span class="toc-text">抽象屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Type-Checking-and-Casting"><span class="toc-number">1.1.20.</span> <span class="toc-text">Type Checking and Casting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Expressions"><span class="toc-number">1.1.21.</span> <span class="toc-text">Expressions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Casting"><span class="toc-number">1.1.22.</span> <span class="toc-text">Casting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Inheritance-Cheatsheet"><span class="toc-number">1.1.23.</span> <span class="toc-text">Inheritance Cheatsheet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Higher-Order-Functions"><span class="toc-number">1.1.24.</span> <span class="toc-text">Higher Order Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3Subtype-Polymorphism"><span class="toc-number">1.1.24.1.</span> <span class="toc-text">4.3Subtype Polymorphism</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Comparables"><span class="toc-number">1.1.25.</span> <span class="toc-text">Comparables</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Comparator"><span class="toc-number">1.1.26.</span> <span class="toc-text">Comparator</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2Throwing-Exceptions"><span class="toc-number">1.1.26.1.</span> <span class="toc-text">6.2Throwing Exceptions</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-3Iteration"><span class="toc-number">1.1.26.2.</span> <span class="toc-text">6.3Iteration</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Implementing-Iterators"><span class="toc-number">1.1.27.</span> <span class="toc-text">Implementing Iterators</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Object-Methods"><span class="toc-number">1.1.27.1.</span> <span class="toc-text">Object Methods</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#toString-NaN"><span class="toc-number">1.1.28.</span> <span class="toc-text">toString()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#equals"><span class="toc-number">1.1.29.</span> <span class="toc-text">equals()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#equals-Object-o"><span class="toc-number">1.1.30.</span> <span class="toc-text">equals(Object o)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Efficient-Programming"><span class="toc-number">1.1.30.1.</span> <span class="toc-text">Efficient Programming</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E5%90%88%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89"><span class="toc-number">1.1.30.2.</span> <span class="toc-text">不相交集合（并查集）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Quick-Find"><span class="toc-number">1.1.31.</span> <span class="toc-text">Quick Find</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Quick-Union"><span class="toc-number">1.1.32.</span> <span class="toc-text">Quick Union</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Weighted-Quick-Union-WQU-%E5%8A%A0%E6%9D%83%E5%BF%AB%E9%80%9F%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.1.33.</span> <span class="toc-text">Weighted Quick Union (WQU)加权快速并查集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Weighted-Quick-Union-with-Path-Compression"><span class="toc-number">1.1.34.</span> <span class="toc-text">Weighted Quick Union with Path Compression</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Binary-Search%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.1.35.</span> <span class="toc-text">Binary Search二分查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Merge-Sort%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.36.</span> <span class="toc-text">Merge Sort归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ADTs"><span class="toc-number">1.1.36.1.</span> <span class="toc-text">ADTs</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Trees"><span class="toc-number">1.1.36.2.</span> <span class="toc-text">Trees</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Binary-Search-Trees"><span class="toc-number">1.1.37.</span> <span class="toc-text">Binary Search Trees</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Binary-Search-Tree-Operations"><span class="toc-number">1.1.38.</span> <span class="toc-text">Binary Search Tree Operations</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Balanced-Search-Trees"><span class="toc-number">1.1.38.1.</span> <span class="toc-text">Balanced Search Trees</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-Trees"><span class="toc-number">1.1.38.2.</span> <span class="toc-text">B-Trees</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Insertion-Process-%E6%8F%92%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.39.</span> <span class="toc-text">Insertion Process 插入过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#B-Tree-invariants"><span class="toc-number">1.1.39.1.</span> <span class="toc-text">B-Tree invariants</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#runtime-%E6%80%BB%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E6%98%AF-O-logN"><span class="toc-number">1.1.40.</span> <span class="toc-text">runtime:总运行时间是 O(logN)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Rotating-Trees"><span class="toc-number">1.1.40.1.</span> <span class="toc-text">Rotating Trees</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Red-Black-Trees"><span class="toc-number">1.1.40.2.</span> <span class="toc-text">Red-Black Trees</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A6%E5%80%BE%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8E-2-3-%E6%A0%91%E4%B8%80%E4%B8%80%E5%AF%B9%E5%BA%94%E3%80%82%E6%AF%8F%E4%B8%AA-2-3-%E6%A0%91%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E7%9A%84%E5%B7%A6%E5%80%BE%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8E%E4%B9%8B%E5%85%B3%E8%81%94%E3%80%82%E8%87%B3%E4%BA%8E-2-3-4-%E6%A0%91%EF%BC%8C%E5%AE%83%E4%BB%AC%E4%B8%8E%E6%A0%87%E5%87%86%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BF%9D%E6%8C%81%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E3%80%82"><span class="toc-number">1.1.40.3.</span> <span class="toc-text">左倾红黑树与 2-3 树一一对应。每个 2-3 树都有一个唯一的左倾红黑树与之关联。至于 2-3-4 树，它们与标准红黑树保持对应关系。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Properties-of-LLRB%E2%80%99s"><span class="toc-number">1.1.41.</span> <span class="toc-text">Properties of LLRB’s</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Properties-of-Red-Black-Trees"><span class="toc-number">1.1.42.</span> <span class="toc-text">Properties of Red-Black Trees</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runtime"><span class="toc-number">1.1.43.</span> <span class="toc-text">Runtime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hashing"><span class="toc-number">1.1.44.</span> <span class="toc-text">Hashing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Properties-of-HashCodes"><span class="toc-number">1.1.45.</span> <span class="toc-text">Properties of HashCodes</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.45.1.</span> <span class="toc-text">1. 哈希表的基本工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%A4%84%E7%90%86%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.45.2.</span> <span class="toc-text">2. 处理性能问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Heaps"><span class="toc-number">1.1.45.3.</span> <span class="toc-text">Heaps</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Tree-Traversal"><span class="toc-number">1.1.45.4.</span> <span class="toc-text">Tree Traversal</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Level-Order-Traversal%EF%BC%88%E6%98%AF%E4%B8%80%E7%A7%8DBFS"><span class="toc-number">1.1.46.</span> <span class="toc-text">Level Order Traversal（是一种BFS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Depth-First-traversals-%E2%80%93%E2%80%93-of-which-there-are-three-pre-order-in-order-and-post-order-%EF%BC%88DFS%EF%BC%89"><span class="toc-number">1.1.47.</span> <span class="toc-text">Depth-First traversals –– of which there are three: pre-order, in-order and post-order.（DFS）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Representing-Graphs"><span class="toc-number">1.1.48.</span> <span class="toc-text">Representing Graphs</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Shortest-Paths"><span class="toc-number">1.1.48.1.</span> <span class="toc-text">Shortest Paths</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-2-dijkstra"><span class="toc-number">1.1.49.</span> <span class="toc-text">19.2 dijkstra</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#19-3-A"><span class="toc-number">1.1.49.1.</span> <span class="toc-text">19.3 A*</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Minimum-Spanning-Trees"><span class="toc-number">1.1.49.2.</span> <span class="toc-text">Minimum Spanning Trees</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-1MSTs-and-Cut-Property"><span class="toc-number">1.1.50.</span> <span class="toc-text">20.1MSTs and Cut Property</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-2-Prim-and-Kruskal"><span class="toc-number">1.1.51.</span> <span class="toc-text">20.2 Prim and Kruskal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Prim%E7%AE%97%E6%B3%95%EF%BC%88%E6%9C%B4%E7%B4%A0%E7%89%88%EF%BC%89-%E2%86%92-%E2%80%9C%E5%87%BA%E5%9C%88%E6%B3%95%E2%80%9D"><span class="toc-number">1.1.52.</span> <span class="toc-text">1. Prim算法（朴素版） → “出圈法”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Prim%E7%AE%97%E6%B3%95%EF%BC%88%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88%EF%BC%89-%E2%86%92-%E2%80%9C%E5%87%BA%E9%98%9F%E6%B3%95%E2%80%9D"><span class="toc-number">1.1.53.</span> <span class="toc-text">2. Prim算法（堆优化版） → “出队法”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Kruskal%E7%AE%97%E6%B3%95-%E2%86%92-%E2%80%9C%E5%8A%A0%E8%BE%B9%E6%B3%95%E2%80%9D"><span class="toc-number">1.1.54.</span> <span class="toc-text">3. Kruskal算法 → “加边法”</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/31/%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9%E5%B7%A5%E5%85%B7/" title="待办事项工具">待办事项工具</a><time datetime="2025-03-30T16:00:00.000Z" title="Created 2025-03-31 00:00:00">2025-03-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/09/hello-world/" title="Hello World">Hello World</a><time datetime="2025-03-09T14:44:31.477Z" title="Created 2025-03-09 22:44:31">2025-03-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/09/CS61Bnote/" title="CS61Bnote">CS61Bnote</a><time datetime="2025-03-08T16:00:00.000Z" title="Created 2025-03-09 00:00:00">2025-03-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/09/test/" title="测试文章">测试文章</a><time datetime="2025-03-08T16:00:00.000Z" title="Created 2025-03-09 00:00:00">2025-03-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/space.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By LST</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>